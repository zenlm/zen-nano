---
title: Photon Protocol
description: Light-based peer selection with luminance tracking
---

# Photon Protocol

Photon implements a light-themed peer selection mechanism using luminance tracking to identify high-performance nodes in the network.

## Overview

Photon replaces traditional random sampling with performance-weighted selection:
- **Luminance**: Node performance metric (10-1000 lux)
- **Emission**: Process of selecting peers based on luminance
- **Emitter**: Component that manages peer selection
- **Brightness**: Aggregate network performance

## Core Concepts

### Luminance Scale

Nodes are rated on a luminance scale from 10 to 1000 lux:

| Luminance | Performance | Description |
|-----------|-------------|-------------|
| 10-100 lux | Low | New or recovering nodes |
| 100-400 lux | Medium | Average performance nodes |
| 400-700 lux | High | Well-performing nodes |
| 700-1000 lux | Elite | Top-tier validators |

### Emission Process

```go
type Emitter interface {
    // Emit selects peers based on luminance
    Emit(count int) []Peer
    
    // UpdateLuminance adjusts peer performance
    UpdateLuminance(peerID ids.ID, delta int32)
    
    // GetBrightness returns network aggregate
    GetBrightness() float64
}
```

## Implementation

### Basic Usage

```go
import (
    "github.com/luxfi/consensus/photon"
)

// Create emitter with peers
peers := network.GetPeers()
emitter := photon.NewEmitter(peers, photon.DefaultOptions())

// Emit high-performance peers
selected := emitter.Emit(20)

// Update peer luminance based on performance
for _, peer := range selected {
    if peer.RespondedQuickly() {
        emitter.UpdateLuminance(peer.ID, +50)
    } else {
        emitter.UpdateLuminance(peer.ID, -20)
    }
}
```

### Configuration

```go
type Options struct {
    // Luminance parameters
    MinLuminance     uint32 // Minimum luminance (default: 10)
    MaxLuminance     uint32 // Maximum luminance (default: 1000)
    InitialLuminance uint32 // Starting luminance (default: 100)
    
    // Emission parameters
    EmissionRate     uint32 // Emissions per second
    WeightedSelection bool   // Use luminance weighting
    
    // Performance tracking
    WindowSize       int    // Performance history window
    DecayFactor      float64 // Historical decay rate
}
```

## Luminance Calculation

### Performance Metrics

```go
type PerformanceMetrics struct {
    ResponseTime    time.Duration // Network latency
    Uptime         float64       // Availability percentage
    Throughput     float64       // Messages per second
    CorrectVotes   int          // Consensus accuracy
    StakeWeight    uint64       // Validator stake
}

func CalculateLuminance(metrics PerformanceMetrics) uint32 {
    score := 0.0
    
    // Response time (lower is better)
    if metrics.ResponseTime < 50*time.Millisecond {
        score += 250
    } else if metrics.ResponseTime < 100*time.Millisecond {
        score += 150
    } else {
        score += 50
    }
    
    // Uptime
    score += metrics.Uptime * 200
    
    // Throughput
    score += math.Min(metrics.Throughput/100, 200)
    
    // Accuracy
    accuracy := float64(metrics.CorrectVotes) / 100.0
    score += accuracy * 150
    
    // Stake weight (logarithmic)
    stakeBonus := math.Log10(float64(metrics.StakeWeight)) * 20
    score += math.Min(stakeBonus, 200)
    
    return uint32(math.Min(math.Max(score, 10), 1000))
}
```

### Dynamic Adjustment

```go
func (e *Emitter) AdjustLuminance(peerID ids.ID, event Event) {
    current := e.GetLuminance(peerID)
    
    switch event.Type {
    case EventFastResponse:
        e.SetLuminance(peerID, min(current+50, e.maxLuminance))
    
    case EventSlowResponse:
        e.SetLuminance(peerID, max(current-30, e.minLuminance))
    
    case EventCorrectVote:
        e.SetLuminance(peerID, min(current+10, e.maxLuminance))
    
    case EventIncorrectVote:
        e.SetLuminance(peerID, max(current-50, e.minLuminance))
    
    case EventOffline:
        e.SetLuminance(peerID, e.minLuminance)
    }
}
```

## Emission Strategies

### Weighted Random Selection

```go
func (e *Emitter) WeightedEmit(count int) []Peer {
    // Calculate total luminance
    totalLuminance := e.GetTotalLuminance()
    
    selected := make([]Peer, 0, count)
    for i := 0; i < count; i++ {
        // Random value in [0, totalLuminance)
        target := rand.Float64() * totalLuminance
        
        // Find peer at target luminance
        cumulative := 0.0
        for _, peer := range e.peers {
            cumulative += float64(peer.Luminance)
            if cumulative >= target {
                selected = append(selected, peer)
                break
            }
        }
    }
    
    return selected
}
```

### Tiered Selection

```go
func (e *Emitter) TieredEmit(count int) []Peer {
    // Categorize peers by luminance tier
    elite := e.GetPeersByLuminance(700, 1000)
    high := e.GetPeersByLuminance(400, 700)
    medium := e.GetPeersByLuminance(100, 400)
    low := e.GetPeersByLuminance(10, 100)
    
    // Select proportionally from each tier
    selected := make([]Peer, 0, count)
    selected = append(selected, e.SelectFrom(elite, count*40/100)...)
    selected = append(selected, e.SelectFrom(high, count*30/100)...)
    selected = append(selected, e.SelectFrom(medium, count*20/100)...)
    selected = append(selected, e.SelectFrom(low, count*10/100)...)
    
    return selected[:count]
}
```

## Network Brightness

### Aggregate Metrics

```go
type NetworkBrightness struct {
    AverageLuminance float64
    MedianLuminance  uint32
    TopPercentile    uint32 // 90th percentile
    Distribution     map[string]int // Tier distribution
}

func (e *Emitter) GetNetworkBrightness() NetworkBrightness {
    luminances := e.GetAllLuminances()
    
    return NetworkBrightness{
        AverageLuminance: Average(luminances),
        MedianLuminance:  Median(luminances),
        TopPercentile:    Percentile(luminances, 90),
        Distribution:     e.GetTierDistribution(),
    }
}
```

### Brightness Monitoring

```go
// Monitor network brightness over time
monitor := photon.NewBrightnessMonitor(emitter)

monitor.OnBrightnessChange(func(old, new float64) {
    if new < old*0.8 {
        log.Warn("Network brightness decreased by 20%")
    }
})

// Get brightness history
history := monitor.GetHistory(24 * time.Hour)
for _, point := range history {
    fmt.Printf("%v: %.2f lux\n", point.Time, point.Brightness)
}
```

## Integration Examples

### With Consensus

```go
// Use Photon for validator selection
consensus := NewConsensusEngine()
emitter := photon.NewEmitter(validators, options)

// Select high-luminance validators for block production
producers := emitter.Emit(21)
consensus.SetBlockProducers(producers)

// Adjust luminance based on block production
consensus.OnBlockProduced(func(producer ids.ID, block Block) {
    emitter.UpdateLuminance(producer, +100)
})
```

### With Network Layer

```go
// Prioritize high-luminance peers for messaging
network.SetPeerPrioritizer(func(peers []Peer) []Peer {
    // Sort by luminance
    sort.Slice(peers, func(i, j int) bool {
        return emitter.GetLuminance(peers[i].ID) > 
               emitter.GetLuminance(peers[j].ID)
    })
    return peers
})
```

## Performance Optimization

### Caching

```go
type CachedEmitter struct {
    *Emitter
    cache     map[string][]Peer
    cacheTime map[string]time.Time
    ttl       time.Duration
}

func (e *CachedEmitter) Emit(count int) []Peer {
    key := fmt.Sprintf("%d", count)
    
    // Check cache
    if peers, ok := e.cache[key]; ok {
        if time.Since(e.cacheTime[key]) < e.ttl {
            return peers
        }
    }
    
    // Emit and cache
    peers := e.Emitter.Emit(count)
    e.cache[key] = peers
    e.cacheTime[key] = time.Now()
    
    return peers
}
```

### Batch Updates

```go
func (e *Emitter) BatchUpdateLuminance(updates map[ids.ID]int32) {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    for peerID, delta := range updates {
        current := e.luminance[peerID]
        new := int32(current) + delta
        
        // Clamp to valid range
        if new < int32(e.minLuminance) {
            new = int32(e.minLuminance)
        } else if new > int32(e.maxLuminance) {
            new = int32(e.maxLuminance)
        }
        
        e.luminance[peerID] = uint32(new)
    }
    
    // Recalculate network brightness
    e.updateBrightness()
}
```

## Best Practices

1. **Regular Updates**: Update luminance after each interaction
2. **Gradual Changes**: Avoid drastic luminance changes
3. **Historical Decay**: Weight recent performance more heavily
4. **Tier Balance**: Maintain diversity in peer selection
5. **Performance Monitoring**: Track brightness trends

## See Also

- [Quasar Protocol](/docs/protocols/quasar)
- [Wave Protocol](/docs/protocols/wave)
- [Network Architecture](/docs/architecture/network)
- [Performance Tuning](/docs/operations/tuning)